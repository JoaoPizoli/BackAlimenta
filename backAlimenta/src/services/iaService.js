const OpenAI = require('openai');
const fs = require('fs');
const path = require('path');

class IAService {
    constructor() {
        // ATEN√á√ÉO: Esta chave est√° exposta! Mova para vari√°vel de ambiente
        this.openai = new OpenAI({
            apiKey: "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"
        });
    }    // M√âTODO DE TRANSCRI√á√ÉO REMOVIDO
    // A transcri√ß√£o agora √© feita diretamente no Flutter usando OpenAI
    // Este servi√ßo agora √© respons√°vel apenas pela extra√ß√£o de informa√ß√µes do texto transcrito

    async extrairAlimentoEQuantidade(texto) {
        const logPrefix = '[EXTRA√á√ÉO_IA]';
        const startTime = Date.now();
        
        try {
            console.log(`${logPrefix} ü§ñ Iniciando extra√ß√£o de alimento e quantidade...`);
            console.log(`${logPrefix} ‚è∞ Timestamp: ${new Date().toISOString()}`);
            console.log(`${logPrefix} üìù Texto recebido:`, {
                texto_original: texto,
                tamanho: texto?.length || 0,
                tipo: typeof texto
            });

            // Validar entrada de forma detalhada
            if (texto === null || texto === undefined) {
                throw new Error('ENTRADA_NULA: Texto √© null ou undefined');
            }

            if (typeof texto !== 'string') {
                console.warn(`${logPrefix} ‚ö†Ô∏è Convers√£o de tipo: ${typeof texto} -> string`);
                texto = String(texto);
            }

            const textoLimpo = texto.trim();
            if (textoLimpo.length === 0) {
                throw new Error('ENTRADA_VAZIA: Texto vazio ap√≥s trim()');
            }

            if (textoLimpo.length < 3) {
                throw new Error(`ENTRADA_MUITO_CURTA: Apenas ${textoLimpo.length} caracteres`);
            }

            console.log(`${logPrefix} ‚úÖ Valida√ß√£o de entrada OK`, {
                texto_limpo: textoLimpo,
                tamanho_final: textoLimpo.length
            });

            // Preparar prompt otimizado
            const prompt = `
Voc√™ √© um especialista em nutri√ß√£o. Analise o texto abaixo e extraia as informa√ß√µes sobre alimentos consumidos.

REGRAS:
1. Identifique APENAS o nome do alimento principal (sem quantidades no nome)
2. Identifique a quantidade consumida em gramas
3. Se n√£o mencionar quantidade, assuma 100g
4. Se mencionar "1 unidade", "1 fatia", etc., converta para gramas usando valores padr√£o
5. Responda SEMPRE no formato JSON exato abaixo
6. Use nomes simples e limpos para os alimentos
7. Considere sin√¥nimos e varia√ß√µes regionais

CONVERS√ïES PADR√ÉO:
- 1 banana m√©dia = 120g
- 1 fatia de p√£o = 25g
- 1 ovo = 50g
- 1 x√≠cara de arroz = 150g
- 1 colher de sopa = 15g
- 1 copo (200ml) = 200g
- 1 prato de comida = 300g
- 1 por√ß√£o = 150g

FORMATO DE RESPOSTA (JSON):
{
  "nome": "nome_do_alimento_limpo",
  "quantidade": numero_em_gramas,
  "confianca": numero_de_0_a_100,
  "observacoes": "detalhes_adicionais_se_necessario"
}

TEXTO PARA ANALISAR: "${textoLimpo}"

IMPORTANTE: Responda APENAS com o JSON v√°lido, sem texto adicional.`;

            console.log(`${logPrefix} üì§ Configura√ß√£o para OpenAI:`, {
                modelo: "gpt-4o-mini",
                temperatura: 0.1,
                max_tokens: 300,
                tamanho_prompt: prompt.length
            });

            console.log(`${logPrefix} üöÄ Enviando requisi√ß√£o para OpenAI...`);
            const openaiStart = Date.now();

            let completion;
            try {
                completion = await this.openai.chat.completions.create({
                    model: "gpt-4o-mini", // Modelo mais econ√¥mico e eficiente
                    messages: [
                        {
                            role: "system",
                            content: "Voc√™ √© um especialista em nutri√ß√£o que extrai informa√ß√µes de alimentos de forma precisa. Sempre responda apenas com JSON v√°lido, sem markdown ou texto adicional."
                        },
                        {
                            role: "user",
                            content: prompt
                        }
                    ],
                    temperature: 0.1,
                    max_tokens: 300
                });

                const openaiTime = Date.now() - openaiStart;
                console.log(`${logPrefix} ‚è±Ô∏è Tempo de resposta OpenAI: ${openaiTime}ms`);
                console.log(`${logPrefix} ‚úÖ Resposta recebida da OpenAI`);
                
            } catch (openaiError) {
                console.error(`${logPrefix} ‚ùå ERRO na API OpenAI:`, {
                    message: openaiError.message,
                    code: openaiError.code,
                    type: openaiError.type,
                    status: openaiError.status
                });
                throw new Error(`OPENAI_ERROR: ${openaiError.message}`);
            }

            // Processar resposta da IA
            let resposta = completion.choices[0].message.content.trim();
            console.log(`${logPrefix} üìã Resposta bruta da IA:`, {
                conteudo: resposta,
                tamanho: resposta.length,
                tokens_usados: completion.usage
            });

            // Limpar markdown se presente
            const respostaOriginal = resposta;
            resposta = resposta.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
            
            if (respostaOriginal !== resposta) {
                console.log(`${logPrefix} üßπ Markdown removido da resposta`);
            }

            console.log(`${logPrefix} üîç Resposta limpa:`, resposta);

            // Tentar parsear o JSON
            let resultado;
            try {
                resultado = JSON.parse(resposta);
                console.log(`${logPrefix} ‚úÖ JSON parseado com sucesso:`, resultado);
            } catch (parseError) {
                console.error(`${logPrefix} ‚ùå ERRO ao parsear JSON:`, {
                    erro: parseError.message,
                    resposta_problematica: resposta,
                    caractere_problema: parseError.message.match(/position (\d+)/)?.[1]
                });
                throw new Error(`JSON_PARSE_ERROR: ${parseError.message}`);
            }
            
            // Valida√ß√£o estrutural detalhada
            const validationErrors = [];
            
            if (!resultado.nome) {
                validationErrors.push('Campo "nome" ausente ou vazio');
            } else if (typeof resultado.nome !== 'string') {
                validationErrors.push(`Campo "nome" deve ser string, recebido: ${typeof resultado.nome}`);
            }

            if (resultado.quantidade === null || resultado.quantidade === undefined) {
                validationErrors.push('Campo "quantidade" ausente');
            } else if (typeof resultado.quantidade !== 'number') {
                validationErrors.push(`Campo "quantidade" deve ser number, recebido: ${typeof resultado.quantidade}`);
            }

            if (validationErrors.length > 0) {
                console.error(`${logPrefix} ‚ùå ERROS de valida√ß√£o:`, validationErrors);
                throw new Error(`VALIDATION_ERROR: ${validationErrors.join('; ')}`);
            }

            // Valida√ß√£o de valores
            if (resultado.quantidade <= 0) {
                console.error(`${logPrefix} ‚ùå Quantidade inv√°lida: ${resultado.quantidade} (deve ser > 0)`);
                throw new Error(`QUANTIDADE_INVALIDA: ${resultado.quantidade} <= 0`);
            }

            if (resultado.quantidade > 5000) {
                console.error(`${logPrefix} ‚ùå Quantidade muito alta: ${resultado.quantidade}g (limite: 5000g)`);
                throw new Error(`QUANTIDADE_EXCESSIVA: ${resultado.quantidade}g > 5000g`);
            }

            // Limpar e validar nome
            const nomeOriginal = resultado.nome;
            resultado.nome = resultado.nome.toLowerCase().trim();
            
            if (nomeOriginal !== resultado.nome) {
                console.log(`${logPrefix} üßπ Nome normalizado: "${nomeOriginal}" -> "${resultado.nome}"`);
            }

            if (resultado.nome.length < 2) {
                console.error(`${logPrefix} ‚ùå Nome muito curto: "${resultado.nome}" (${resultado.nome.length} chars)`);
                throw new Error(`NOME_MUITO_CURTO: "${resultado.nome}"`);
            }

            // Log de sucesso com estat√≠sticas
            const totalTime = Date.now() - startTime;
            console.log(`${logPrefix} üéâ SUCESSO na extra√ß√£o!`, {
                resultado_final: resultado,
                tempo_total: totalTime + 'ms',
                confianca: resultado.confianca || 'N/A'
            });

            return { status: true, dados: resultado };

        } catch (error) {
            const totalTime = Date.now() - startTime;
            console.error(`${logPrefix} ‚ùå ERRO GERAL na extra√ß√£o:`, {
                erro: error.message,
                tipo: error.constructor.name,
                tempo_ate_erro: totalTime + 'ms',
                texto_processado: texto?.substring(0, 50) + '...'
            });
            
            console.log(`${logPrefix} üîÑ Tentando m√©todo de fallback (regex)...`);
            
            // Fallback: tentar extra√ß√£o simples com regex
            try {
                const fallback = this.extrairComRegex(texto);
                if (fallback.status) {
                    console.log(`${logPrefix} ‚úÖ Fallback bem-sucedido!`);
                    return fallback;
                } else {
                    console.log(`${logPrefix} ‚ùå Fallback tamb√©m falhou`);
                }
            } catch (fallbackError) {
                console.error(`${logPrefix} ‚ùå Erro no fallback:`, fallbackError.message);
            }
            
            return { 
                status: false, 
                error: error.message,
                debug_info: {
                    tempo_ate_erro: totalTime + 'ms',
                    metodo_fallback_tentado: true,
                    timestamp: new Date().toISOString()
                }
            };
        }
    }

    extrairComRegex(texto) {
        const logPrefix = '[REGEX_FALLBACK]';
        
        try {
            console.log(`${logPrefix} üîÑ Tentando extra√ß√£o com regex...`);
            console.log(`${logPrefix} üìù Texto para regex:`, texto);
            
            const textoLimpo = texto.toLowerCase().trim();
            
            // Regex melhorada para encontrar quantidades
            const regexQuantidade = /(\d+(?:[.,]\d+)?)\s*(g|gramas?|kg|quilos?|unidades?|fatias?|copos?|x√≠caras?|colheres?)/i;
            const matchQuantidade = textoLimpo.match(regexQuantidade);
            
            console.log(`${logPrefix} üîç Match quantidade:`, matchQuantidade);
            
            let quantidade = 100; // padr√£o
            if (matchQuantidade) {
                let valor = parseFloat(matchQuantidade[1].replace(',', '.'));
                const unidade = matchQuantidade[2].toLowerCase();
                
                console.log(`${logPrefix} üìä Valor: ${valor}, Unidade: ${unidade}`);
                
                // Convers√µes baseadas na unidade
                if (unidade.includes('kg') || unidade.includes('quilo')) {
                    quantidade = valor * 1000;
                } else if (unidade.includes('unidade')) {
                    quantidade = valor * 120; // assumindo banana m√©dia
                } else if (unidade.includes('fatia')) {
                    quantidade = valor * 25; // fatia de p√£o
                } else if (unidade.includes('copo')) {
                    quantidade = valor * 200;
                } else if (unidade.includes('x√≠cara')) {
                    quantidade = valor * 150;
                } else if (unidade.includes('colher')) {
                    quantidade = valor * 15;
                } else {
                    quantidade = valor; // j√° em gramas
                }
                
                console.log(`${logPrefix} ‚öñÔ∏è Quantidade convertida: ${quantidade}g`);
            }

            // Tentar extrair nome do alimento
            let nome = textoLimpo
                .replace(/\d+(?:[.,]\d+)?\s*(g|gramas?|kg|quilos?|unidades?|fatias?|copos?|x√≠caras?|colheres?)/gi, '')
                .replace(/[^\w\s√°√†√¢√£√©√®√™√≠√¨√Æ√≥√≤√¥√µ√∫√π√ª√ß]/g, '')
                .replace(/\s+/g, ' ')
                .trim();

            console.log(`${logPrefix} üè∑Ô∏è Nome extra√≠do inicialmente: "${nome}"`);

            // Se nome muito curto, tentar palavras-chave comuns
            if (nome.length < 3) {
                const palavrasComuns = ['banana', 'p√£o', 'arroz', 'feij√£o', 'frango', 'ovo'];
                const palavraEncontrada = palavrasComuns.find(palavra => 
                    textoLimpo.includes(palavra)
                );
                if (palavraEncontrada) {
                    nome = palavraEncontrada;
                    console.log(`${logPrefix} üéØ Palavra-chave encontrada: "${nome}"`);
                }
            }

            if (!nome || nome.length < 2) {
                console.error(`${logPrefix} ‚ùå Nome inv√°lido: "${nome}"`);
                throw new Error('N√£o foi poss√≠vel extrair o nome do alimento');
            }

            const resultado = {
                nome: nome,
                quantidade: Math.round(quantidade),
                confianca: 50, // confian√ßa m√©dia para regex
                observacoes: 'Extra√ß√£o por regex - verificar precis√£o'
            };

            console.log(`${logPrefix} ‚úÖ Extra√ß√£o por regex conclu√≠da:`, resultado);
            return { status: true, dados: resultado };

        } catch (error) {
            console.error(`${logPrefix} ‚ùå Erro na extra√ß√£o por regex:`, error.message);
            return { 
                status: false, 
                error: error.message,
                dados: {
                    nome: 'alimento_n√£o_identificado',
                    quantidade: 100,
                    confianca: 10,
                    observacoes: 'Falha na extra√ß√£o - valores padr√£o aplicados'
                }
            };
        }
    }

    // M√©todo auxiliar para limpar arquivos tempor√°rios
    cleanupTempFile(filePath) {
        const logPrefix = '[CLEANUP]';
        
        try {
            if (fs.existsSync(filePath)) {
                fs.unlinkSync(filePath);
                console.log(`${logPrefix} üóëÔ∏è Arquivo tempor√°rio removido: ${filePath}`);
            } else {
                console.log(`${logPrefix} ‚ö†Ô∏è Arquivo j√° n√£o existe: ${filePath}`);
            }
        } catch (error) {
            console.error(`${logPrefix} ‚ùå Erro ao remover arquivo tempor√°rio:`, {
                arquivo: filePath,
                erro: error.message
            });
        }
    }

    // M√©todo auxiliar para detalhes de erro
    getErrorDetails(error) {
        const details = {
            tipo: error.constructor.name,
            codigo: error.code || 'N/A',
            timestamp: new Date().toISOString()
        };

        if (error.response) {
            details.status = error.response.status;
            details.statusText = error.response.statusText;
            details.data = error.response.data;
        }

        if (error.config) {
            details.request_config = {
                method: error.config.method,
                url: error.config.url,
                headers: error.config.headers
            };
        }

        return details;
    }

    // M√©todo para validar se a API est√° funcionando
    async testarConexao() {
        const logPrefix = '[TESTE_CONEXAO]';
        
        try {
            console.log(`${logPrefix} üîó Testando conex√£o com OpenAI...`);
            
            const models = await this.openai.models.list();
            
            console.log(`${logPrefix} ‚úÖ Conex√£o bem-sucedida!`, {
                total_modelos: models.data.length,
                primeiro_modelo: models.data[0]?.id || 'N/A'
            });
            
            return { 
                status: true, 
                message: 'Conex√£o com OpenAI OK',
                modelos: models.data.length,
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            console.error(`${logPrefix} ‚ùå Erro na conex√£o:`, {
                erro: error.message,
                detalhes: this.getErrorDetails(error)
            });
            
            return { 
                status: false, 
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }
}

module.exports = new IAService();